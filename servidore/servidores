======= APUNTES SERVIDORES ========

Desde local: git remote prune origin -> para eliminar las ramas remotas que ya no valen para nada.

_PHP_:
los metodos que empiezan por mb_... tienen en cuenta el multiByte. Las cadenas de string en php, son lastres de bytes.

----------------
COMPROBACIONES:
-----------------
		de tipos (isDigit(), is_numeric(),...)
		de valores (ctype_alpha, ctype_...)
----------------------
CONVERSIONES DE TIPO:
----------------------
			(int) $x --> Casting de toda la vida
			(float)
			(string) $x --> Casting a cadena

pero tb hay funciones como:

- intval(..) --> Coge algo y devuelve su valor en entero
- floatval(..) --> Coge el valor del argumento y lo convierte a float
- strval(..) --> Convierte su argumento a cadena
- boolval(..) --> same

--------------------------------------------
COMPARACIONES DE VALORES DE TIPOS DISTINTOS:
--------------------------------------------

con el == y el ===,<,>,<=, >= !=, !==, <=>(comparador nave espacial), x ?? y(funcion de null), operador ternario x?y:z, operador elvis x ?: 25

Operador funcion de null:
Es como un coallesce, va buscando nulls.


Operador elvis:
"hola" ?: 25, si lo primero evalua a true, lo devuelve (hola) si no, devuelve lo otro.

-------------|
x <=> y	     |
	     |
-1 --> x<y   |
0  --> x==y  |
1  --> x>y   |
-------------|

Mijitas de la conversion string-->bool
" " --> false : 		(bool) "" = false
"0" --> false			(bool) "0" = false
"resto de cadena" --> true	(bool) "h" = true

-----------
CONSTANTES:
-----------

Para definir constantes:(2 maneras)

-define('NOMBRE_CONSTANTE',74(valor));
-const NOMBRE_CONSTANTE = 74 (valor);

Hay algunas constantes ya definidas:
__LINE__
__FILE__
__DIR__
...

Para saber si hay una constante definida: defined('NOMBRE');
si da true, está definida, si no, false.


--------------------------------
ESTRUCTURAS DE CONTROL
--------------------------------

-if(...) else
-switch(..)
-for(..)
-while(..)
-do...while(..)
((La palabra reservada elseif es mas correcto que usar else if{}..

Otro modo del if:
if (..):
	...
else:
	....
endif;




=============================================================================

INCLUSION DE SCRIPTS

Se pueden incluir contenido php (aux.php) en otros archivos php.

Con:

require 'aux.php'; --> Esto desde f1.php, cuando llega al require, se va a aux.php y ejecuta ese codigo, luego sigue por el require hacia abajo.

En el require hay que poner el nombre del fichero junto con su extensión. El require busca el archivo en primer lugar en 'include_path'(cuando no especificas la ruta completa), luego en el directorio actual.
Por lo que es aconsejable y la mejor opcion es poner una ruta relativa al menos, si no una ruta absoluta.

require './aux.php'; --> Ruta relativa indicando que esta en nuestro directorio actual, así se ahorra de ir al include_path.

También podriamos usar una constante definida.
require __DIR__ . '/aux.php';

Tambien podemos usar include 'aux.php'; que funciona igual pero el require te para el programa si no encuentra el archivo, y el include si no te lo encuentra, te muestra un warning pero continua el programa.

Tambien existe, require_once, include_once, que comprueba si ha habido un require previo a ese archivo, y se lo salta si lo ha ejecutado ya. Es decir, lo incluye si no ha sido incluido ya en la ejecución.

_______
RETURN


El return al final del codigo de un archivo php (por ejemplo aux.php).

aux.php =
<?php

echo 'Esto no lo va a mostrar'

return 'Esto lo muestra';

Luego podemos guardar este return en otro archivo php.
Por ejemplo.

pagina.php =
<?php

$res = require './aux.php';

echo "Voy a mostrar lo que muestra aux.php: $res";


--------------------------------
FUNCIONES isset() y empty()
--------------------------------

isset() --> Determina si una variable esta definida y no es null. Retorna un boolean.

empty() --> Determina si una variable está vacia o su valor evalua a false.


------------------------
	ARRAYS
------------------------

$argv --> Todos los argumentos de un archivo php (al ejecutarse)

$argc --> El numero de argumentos que has pasado.


Cómo se crea un array:

$a = array(23,47,35); --> $a[0] = 23; $a[1] = 47; $a[2] = 35;

ó

$a = [23,47,35];


$a[3]; !ERROR! PORQUE NO ESTA DEFINIDO, OCUPA DE LA 0 A LA 2

Pero lo puedo meter asi:

$a[3] = 99;

Esto incrementa el array. ahora tendria 4 posiciones 0-3

$a[4] = 'hola'; no tienen porque ser del mismo tipo.

$a; --> [23,47,35,99,'hola',] asi lo tendriamos el array.

$[14] = 55; se le puede meter en la clave 14 el valor 55, las demas posiciones sin definir, no existirían. Se van añadiendo por el final, no se ordenan las claves.
Una clave no tiene porque ser numerica, puede ser un string

$a['gato'] = 'cat';


$a[] = 435; Coge la última(mayor) clave y es la que se le aplica a 435.


		OPERADORES DE ARRAY


Podemo sumar arrays (union de dos arrays).
El array de la izquierda, añadiendole los del array de la derecha.
Si hay claves iguales, gana el de la izquierda.

$a = [0=>'a', 1=>'b', 2=>'c'];
$b = [3=>d, 4=>e, 5=>f];

$a + $b ; --> [a,b,c,d,e,f]

$c = [2=>d, 3=>e, 4=>f]

$a + $c ; --> [a,b,c,e,f] --> se pisa la clave 2 y gana la del array $a.


¿Cuándo dos arrays son iguales?

Son iguales si tienen los mismos elementos, las mismas parejas clave-valor.


Y son identicos cuando cuando los valores se evaluan y son iguales.


!= y !== tb se usan.



---------------------------------------------------------------
			FUNCIONES DE ARRAY.
---------------------------------------------------------------

count($a) --> Cuantos elementos tiene un array.
array_sum(...) -->Suma los elementos de un array.
range(0,4) --> Crea un array de los numeros del 0 al 4.
sort($a) --> Ordena por valores el array, devuelve true si lo ha ordenado. elimina las claves.
rsort($a) -->Ordena al reves.
asort($a) --> Ordena por valores pero mantiene las claves, no las pierdes.
arsort($a) --> Ordena por valores al reves y manteniendo las claves.
ksort($a) --> Ordena por claves, y no elimina las claves
krsor($a) --> Ordena al reves por claves.

array_keys($a) --> Devuelve un array solo con las claves.
array_values($a) --> Devuelve un array con los valores.

array_combine(array_keys($a), array_values($a)) --> Combina dos arrays en uno, hay que pasarle como primer parametro un array de claves y luego otro de valores.



array_merge($a) --> sirve para combinar dos arrays. Se modifican las claves de uno de los arrays, y se añaden al final del otro, siguiendo la secuencia numérica de claves de este segundo.

Traversable --> Algo que puedes recorrer.


$a = ['perro' => 'dog', 'gato'  => 'cat'];


foreach ($a as $k => $v){	--> Si solo te interesa los valores $v o $k
	echo "La palabra $k en ingles es $v.\n";
}


---------------------------------
	FUNCIONES
--------------------------------
function suma($a, $b=5){return $a+$b;}

si se usa suma(3,4), sale 7, pero si se le pasa solo un valor, el segundo argumento tomará su valor por defecto que en este caso es 5·

Los valores por defecto debemos indicarlos como ultimos parametros. Por ejemplo $b=5 está detras del $a, no podría ir delante.



ÁMBITOS-->
	'GLOBAL': Las variables que estan definidas a nivel de fichero.Y solo se puede usar a nivel de fichero.

	'LOCAL': Aquella que se define dentro de una función.

	'SUPERGLOBALS': sirven para cualquier ambito, pero ya estan definidas, no se pueden definir nuevas.($_GET,$_POST,_$SESSION,$_COOKIE,..)


Si tenemos una varible global y la queremos usar dentro de una función, deberemos usar:

function(){
global $variable;
...y usarla...
}


Se pueden declarar los tipos de argumentos que pasamos a una función, pero solo pueden ser: int, float, bool, string. Y esto si se le pasa algo que no es del mismo tipo, el interprete se encarga de hacer un conversión implícita.
Al igual que podemos indicar el tipo que retorna una función.

function suma(int $a, int $b):int
{return $a+$b;}


NULLABLE --> hacer un tipo nullable es ponerle ? delante del tipo, ?int --> Permite valores entero y el null.



TIPADO ESTRICTO --> No se define en la misma función, si no que se debe indicar en el archivo donde se llama a la función. La unica excepción es cuando el parametro espera un float y se le pasa un int, SI lo acepta. Es la única excepción.


En el fichero--> Arriba del todo:

declare(strict_types=1);


==========================================0
ORIENTACIÓN A OBJETOS

Las variables guardan referencias a un objeto.
$a = OBJETO;
$b = $a; --> b apunta al mismo objeto que a.
$a = OBJETO1; --> a apunta a un nuevo objeto, pero b sigue apuntando al anterior.

Para acceder a las propiedades y métodos publicos de un objeto usamos ->
$a -> nombre = "Jose";
$b -> saluda();
machacamos la propiedad nombre del objeto.

$a = OBJETO;
$b = &$a; //A b se le asigna por referencia a. b apunta al mimso objeto que a.
$a = OBJETO1; //b tb apunta al nuevo objeto.

$a = OBJETO;
$b = clone $a; -->b apunta a una copia de OBJETO(copia superficial, no profunda) si el OBJETO tuviese objetos como propiedades
				estos no se clonarian, si no que las propiedades objetos de la copia apuntarian a las propiedades objetos del OBJETO

Un objeto es == a otro cuando instancian a la misma clase y cuando sus propiedades tienen los mismos VALORES
Un objeto es === a otro cuando son el mismo objeto.

Podemos usar las constantes de las clases, con el nombre de la clase seguido de la resolución de ámbito (::)
DateTime::ATOM; Llamamos a la constante ATOM de DateTime.


------------------ CLASE DATETIME ----------------
$a = new DateTime;
$a->setTimezone(new DateTimeZone('Europe/Madrid')); --> esto te cambia de UTC, al horario de madrid

-------------------- EXCEPCIONES ----------------------
Instancia de la clase Exception o de la clase Error.
-ErrorException, solo existe para convertir los errores no manejados en excp (Subclase de Exception)
-Exception, para lanzar excepciones propias
-Error, base de todos los errores de php //Convierte en excep los errores.

el archivo erro_reporting se encuentra en /etc/php/7.1/cli/php.ini

Para cazar cualquier exc o error
try{
	...
} catch(Exception|Error $e){
	echo $e->getMessage();
	die();
}

----------------- POSTGRES -----------------------
Para instalar postgresql:
desde .conf/scripts
ejecutamos ./postgresql-install.sh

para ver todas las bases de datos:
sudo -u postgresql psql -l


----------- COMENZAMOS NUESTRO FILMAFFINITY -------
Vamos a crear una base de datos que contengan las peliculas:

peliculas(_id,titulo,anyo,sinopsis,duracion,genero_id(claveAjena))
generos(id,genero)

Para entrar en la base de datos template1 -> sudo -u postgres psql -d template1
Vamos a modificar template1:
create extension pgcrypto; -->creamos esta extensión

HACER SIEMPRE, PARA QUE FUNCIONE

creamos una base de datos(nombre fa): sudo -u postgres createdb fa (fa->filmaffinity)
creamos un usuario (nombre fa): sudo -u postgres createuser -P fa (-P para que te pida la contraseña y generarla)

psql -U fa -h localhost -d fa -> para entrar en la base de datos fa (-d) con el usuario fa (-U) en mi maquina (-h localhost)

psql -U fa -h localhost -d fa < fa.sql : inyecta el archivo fa.sql y lo ejecuta dentro de la base de datos fa con usuario fa.

Desde psysh -> vamos a conectarnos a la base de datos ya creada.
Debemos instanciar a la clase PDO.
$pdo (o $con ) = new PDO('pgsql:host=localhost;dbname=fa'(tipo de base de datos, host nuestro y base de datos a la que nos conectamos),'fa'(usuario),'fa'(contraseña))

Ya tenemos la instancia, podemos trabajar con ella, vamos a hacer un SELECT
$sentencia = $pdo->query('SELECT * from generos;') //devuelve una sentencia, que la guardamos
$res = $sentencia->fetchAll(); //guardo en res, el array que saca el fetchAll() de la sentencia
$res[0][0] = 1; //consulto en el array res, el primero, que a su vez es un array, llamo a la posicion 0
$res[0]['id'] = 1 //id es la primera posicion, de la primera posicion de $res;
 //Se puede llamar por el indice (numero) o por el nombre de la columna ('id');
 query(...) --> te ejecuta una sentencia (select) y te devuelve el resultado de la sentencia;
 fetchAll() --> Te devuelve todas las filas.
 fetch() --> te devuelve la siguiente fila, tiene un contador interno, que sabe que fila te ha dado.
 			si te da false, es que ya no hay mas filas que mostrar.
fetchColumn() --> devuelve columna a columna, de una fila, y va pasando de fila
				por lo que solo se puede coger una columna de cada fila.
rowCount()--> el numero de filas.

$pdo->exec(operaciones que no provoquen resultados, insert,update)-> devuelve el nº de filas afectadas.
$pdo->prepare(); //Aqui dentro usamos marcadores ':'
$pdo->execute([:marcador => valor]);

dentro de la base de datos:
\d -> te dice las bases de datos que hay


	TIPOS SQL --------- TIPOS PHP
	nº Entero ----------- entero
	null ---------------- null
	bool ---------------- bool
	el resto ------------ cadenas




//INTRODUCIR TEMARIO DE TRANSACCIONES **TAREA**
Las transacciones ofrecen Atomicidad, Consistencia, aislamiento y durabilidad. En resumen, hace que un trabajo llevado
a cabo sobre una base de datos, sea aplicado de forma segura y sin interferencias de otras conexiones.
Una transaccion se implementa para hacer que el lote de cambios se aplique a la vez.
Para empezar una transaccion:
PDO::beginTransaction();
para finalizarla:
PDO::commit();
PDO::rollback();


--------------- FILTRADO ------------------
Validación --> solo podemos decir si es valido o no el valor.
Saneado --> podemos también modificar el dato durante el saneado
