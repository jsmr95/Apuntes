======= APUNTES SERVIDORES ========

Desde local: git remote prune origin -> para eliminar las ramas remotas que ya no valen para nada.

_PHP_:
los metodos que empiezan por mb_... tienen en cuenta el multiByte. Las cadenas de string en php, son lastres de bytes.

----------------
COMPROBACIONES:
-----------------		
		de tipos (isDigit(), is_numeric(),...)
		de valores (ctype_alpha, ctype_...)
----------------------
CONVERSIONES DE TIPO:	
----------------------
			(int) $x --> Casting de toda la vida
			(float)
			(string) $x --> Casting a cadena

pero tb hay funciones como:	

- intval(..) --> Coge algo y devuelve su valor en entero
- floatval(..) --> Coge el valor del argumento y lo convierte a float
- strval(..) --> Convierte su argumento a cadena
- boolval(..) --> same

--------------------------------------------
COMPARACIONES DE VALORES DE TIPOS DISTINTOS:
--------------------------------------------

con el == y el ===,<,>,<=, >= !=, !==, <=>(comparador nave espacial), x ?? y(funcion de null), operador ternario x?y:z, operador elvis x ?: 25

Operador funcion de null:
Es como un coallesce, va buscando nulls.


Operador elvis:
"hola" ?: 25, si lo primero evalua a true, lo devuelve (hola) si no, devuelve lo otro.

-------------|
x <=> y	     |
	     |
-1 --> x<y   |
0  --> x==y  |
1  --> x>y   |
-------------|

Mijitas de la conversion string-->bool
" " --> false : 		(bool) "" = false
"0" --> false			(bool) "0" = false
"resto de cadena" --> true	(bool) "h" = true	

-----------
CONSTANTES:
-----------

Para definir constantes:(2 maneras)

-define('NOMBRE_CONSTANTE',74(valor));
-const NOMBRE_CONSTANTE = 74 (valor);

Hay algunas constantes ya definidas:
__LINE__
__FILE__
__DIR__
...

Para saber si hay una constante definida: defined('NOMBRE');
si da true, está definida, si no, false.


--------------------------------
ESTRUCTURAS DE CONTROL
--------------------------------

-if(...) else
-switch(..)
-for(..)
-while(..)
-do...while(..)
((La palabra reservada elseif es mas correcto que usar else if{}..

Otro modo del if:
if (..):
	...
else:
	....
endif;




=============================================================================

INCLUSION DE SCRIPTS

Se pueden incluir contenido php (aux.php) en otros archivos php.

Con:

require 'aux.php'; --> Esto desde f1.php, cuando llega al require, se va a aux.php y ejecuta ese codigo, luego sigue por el require hacia abajo.

En el require hay que poner el nombre del fichero junto con su extensión. El require busca el archivo en primer lugar en 'include_path'(cuando no especificas la ruta completa), luego en el directorio actual.
Por lo que es aconsejable y la mejor opcion es poner una ruta relativa al menos, si no una ruta absoluta.

require './aux.php'; --> Ruta relativa indicando que esta en nuestro directorio actual, así se ahorra de ir al include_path.

También podriamos usar una constante definida.
require __DIR__ . '/aux.php';

Tambien podemos usar include 'aux.php'; que funciona igual pero el require te para el programa si no encuentra el archivo, y el include si no te lo encuentra, te muestra un warning pero continua el programa.

Tambien existe, require_once, include_once, que comprueba si ha habido un require previo a ese archivo, y se lo salta si lo ha ejecutado ya. Es decir, lo incluye si no ha sido incluido ya en la ejecución.

_______
RETURN


El return al final del codigo de un archivo php (por ejemplo aux.php).

aux.php =
<?php

echo 'Esto no lo va a mostrar'

return 'Esto lo muestra';

Luego podemos guardar este return en otro archivo php.
Por ejemplo.

pagina.php =
<?php

$res = require './aux.php';

echo "Voy a mostrar lo que muestra aux.php: $res";


--------------------------------
FUNCIONES isset() y empty()
--------------------------------

isset() --> Determina si una variable esta definida y no es null. Retorna un boolean.

empty() --> Determina si una variable está vacia o su valor evalua a false.


------------------------
	ARRAYS
------------------------

$argv --> Todos los argumentos de un archivo php (al ejecutarse)

$argc --> El numero de argumentos que has pasado.


Cómo se crea un array:

$a = array(23,47,35); --> $a[0] = 23; $a[1] = 47; $a[2] = 35;

ó

$a = [23,47,35];


$a[3]; !ERROR! PORQUE NO ESTA DEFINIDO, OCUPA DE LA 0 A LA 2

Pero lo puedo meter asi:

$a[3] = 99;

Esto incrementa el array. ahora tendria 4 posiciones 0-3

$a[4] = 'hola'; no tienen porque ser del mismo tipo.

$a; --> [23,47,35,99,'hola',] asi lo tendriamos el array.

$[14] = 55; se le puede meter en la clave 14 el valor 55, las demas posiciones sin definir, no existirían. Se van añadiendo por el final, no se ordenan las claves.
Una clave no tiene porque ser numerica, puede ser un string

$a['gato'] = 'cat';


$a[] = 435; Coge la última(mayor) clave y es la que se le aplica a 435.


		OPERADORES DE ARRAY


Podemo sumar arrays (union de dos arrays).
El array de la izquierda, añadiendole los del array de la derecha.
Si hay claves iguales, gana el de la izquierda.

$a = [0=>'a', 1=>'b', 2=>'c'];
$b = [3=>d, 4=>e, 5=>f];

$a + $b ; --> [a,b,c,d,e,f]

$c = [2=>d, 3=>e, 4=>f]

$a + $c ; --> [a,b,c,e,f] --> se pisa la clave 2 y gana la del array $a.


¿Cuándo dos arrays son iguales?

Son iguales si tienen los mismos elementos, las mismas parejas clave-valor.


Y son identicos cuando cuando los valores se evaluan y son iguales.


!= y !== tb se usan.



---------------------------------------------------------------
			FUNCIONES DE ARRAY.	
---------------------------------------------------------------

count($a) --> Cuantos elementos tiene un array.
array_sum(...) -->Suma los elementos de un array.
range(0,4) --> Crea un array de los numeros del 0 al 4.
sort($a) --> Ordena por valores el array, devuelve true si lo ha ordenado. elimina las claves.
rsort($a) -->Ordena al reves.
asort($a) --> Ordena por valores pero mantiene las claves, no las pierdes.
arsort($a) --> Ordena por valores al reves y manteniendo las claves.
ksort($a) --> Ordena por claves, y no elimina las claves
krsor($a) --> Ordena al reves por claves.

array_keys($a) --> Devuelve un array solo con las claves.
array_values($a) --> Devuelve un array con los valores.

array_combine(array_keys($a), array_values($a)) --> Combina dos arrays en uno, hay que pasarle como primer parametro un array de claves y luego otro de valores.



array_merge($a) --> sirve para combinar dos arrays. Se modifican las claves de uno de los arrays, y se añaden al final del otro, siguiendo la secuencia numérica de claves de este segundo.

Traversable --> Algo que puedes recorrer.


$a = ['perro' => 'dog', 'gato'  => 'cat'];


foreach ($a as $k => $v){	--> Si solo te interesa los valores $v o $k
	echo "La palabra $k en ingles es $v.\n";
}


---------------------------------
	FUNCIONES
--------------------------------
function suma($a, $b=5){return $a+$b;}

si se usa suma(3,4), sale 7, pero si se le pasa solo un valor, el segundo argumento tomará su valor por defecto que en este caso es 5·

Los valores por defecto debemos indicarlos como ultimos parametros. Por ejemplo $b=5 está detras del $a, no podría ir delante.



ÁMBITOS-->
	'GLOBAL': Las variables que estan definidas a nivel de fichero.Y solo se puede usar a nivel de fichero.

	'LOCAL': Aquella que se define dentro de una función.

	'SUPERGLOBALS': sirven para cualquier ambito, pero ya estan definidas, no se pueden definir nuevas.($_GET,$_POST,_$SESSION,$_COOKIE,..)


Si tenemos una varible global y la queremos usar dentro de una función, deberemos usar:

function(){
global $variable;
...y usarla...
}


Se pueden declarar los tipos de argumentos que pasamos a una función, pero solo pueden ser: int, float, bool, string. Y esto si se le pasa algo que no es del mismo tipo, el interprete se encarga de hacer un conversión implícita. 
Al igual que podemos indicar el tipo que retorna una función.

function suma(int $a, int $b):int
{return $a+$b;}


NULLABLE --> hacer un tipo nullable es ponerle ? delante del tipo, ?int --> Permite valores entero y el null.



TIPADO ESTRICTO --> No se define en la misma función, si no que se debe indicar en el archivo donde se llama a la función. La unica excepción es cuando el parametro espera un float y se le pasa un int, SI lo acepta. Es la única excepción.


En el fichero--> Arriba del todo:

declare(strict_types=1);










































