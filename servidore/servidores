======= APUNTES SERVIDORES ========

Desde local: git remote prune origin -> para eliminar las ramas remotas que ya no valen para nada.

_PHP_:
los metodos que empiezan por mb_... tienen en cuenta el multiByte. Las cadenas de string en php, son lastres de bytes.

----------------
COMPROBACIONES:
-----------------
		de tipos (isDigit(), is_numeric(),...)
		de valores (ctype_alpha, ctype_...)
----------------------
CONVERSIONES DE TIPO:
----------------------
			(int) $x --> Casting de toda la vida
			(float)
			(string) $x --> Casting a cadena

pero tb hay funciones como:

- intval(..) --> Coge algo y devuelve su valor en entero
- floatval(..) --> Coge el valor del argumento y lo convierte a float
- strval(..) --> Convierte su argumento a cadena
- boolval(..) --> same

--------------------------------------------
COMPARACIONES DE VALORES DE TIPOS DISTINTOS:
--------------------------------------------

con el == y el ===,<,>,<=, >= !=, !==, <=>(comparador nave espacial), x ?? y(funcion de null), operador ternario x?y:z, operador elvis x ?: 25

Operador funcion de null:
Es como un coallesce, va buscando nulls.


Operador elvis:
"hola" ?: 25, si lo primero evalua a true, lo devuelve (hola) si no, devuelve lo otro.

-------------|
x <=> y	     |
	     |
-1 --> x<y   |
0  --> x==y  |
1  --> x>y   |
-------------|

Mijitas de la conversion string-->bool
" " --> false : 		(bool) "" = false
"0" --> false			(bool) "0" = false
"resto de cadena" --> true	(bool) "h" = true

-----------
CONSTANTES:
-----------

Para definir constantes:(2 maneras)

-define('NOMBRE_CONSTANTE',74(valor));
-const NOMBRE_CONSTANTE = 74 (valor);

Hay algunas constantes ya definidas:
__LINE__
__FILE__
__DIR__
...

Para saber si hay una constante definida: defined('NOMBRE');
si da true, está definida, si no, false.


--------------------------------
ESTRUCTURAS DE CONTROL
--------------------------------

-if(...) else
-switch(..)
-for(..)
-while(..)
-do...while(..)
((La palabra reservada elseif es mas correcto que usar else if{}..

Otro modo del if:
if (..):
	...
else:
	....
endif;




=============================================================================

INCLUSION DE SCRIPTS

Se pueden incluir contenido php (aux.php) en otros archivos php.

Con:

require 'aux.php'; --> Esto desde f1.php, cuando llega al require, se va a aux.php y ejecuta ese codigo, luego sigue por el require hacia abajo.

En el require hay que poner el nombre del fichero junto con su extensión. El require busca el archivo en primer lugar en 'include_path'(cuando no especificas la ruta completa), luego en el directorio actual.
Por lo que es aconsejable y la mejor opcion es poner una ruta relativa al menos, si no una ruta absoluta.

require './aux.php'; --> Ruta relativa indicando que esta en nuestro directorio actual, así se ahorra de ir al include_path.

También podriamos usar una constante definida.
require __DIR__ . '/aux.php';

Tambien podemos usar include 'aux.php'; que funciona igual pero el require te para el programa si no encuentra el archivo, y el include si no te lo encuentra, te muestra un warning pero continua el programa.

Tambien existe, require_once, include_once, que comprueba si ha habido un require previo a ese archivo, y se lo salta si lo ha ejecutado ya. Es decir, lo incluye si no ha sido incluido ya en la ejecución.

_______
RETURN


El return al final del codigo de un archivo php (por ejemplo aux.php).

aux.php =
<?php

echo 'Esto no lo va a mostrar'

return 'Esto lo muestra';

Luego podemos guardar este return en otro archivo php.
Por ejemplo.

pagina.php =
<?php

$res = require './aux.php';

echo "Voy a mostrar lo que muestra aux.php: $res";


--------------------------------
FUNCIONES isset() y empty()
--------------------------------

isset() --> Determina si una variable esta definida y no es null. Retorna un boolean.

empty() --> Determina si una variable está vacia o su valor evalua a false.


------------------------
	ARRAYS
------------------------

$argv --> Todos los argumentos de un archivo php (al ejecutarse)

$argc --> El numero de argumentos que has pasado.


Cómo se crea un array:

$a = array(23,47,35); --> $a[0] = 23; $a[1] = 47; $a[2] = 35;

ó

$a = [23,47,35];


$a[3]; !ERROR! PORQUE NO ESTA DEFINIDO, OCUPA DE LA 0 A LA 2

Pero lo puedo meter asi:

$a[3] = 99;

Esto incrementa el array. ahora tendria 4 posiciones 0-3

$a[4] = 'hola'; no tienen porque ser del mismo tipo.

$a; --> [23,47,35,99,'hola',] asi lo tendriamos el array.

$[14] = 55; se le puede meter en la clave 14 el valor 55, las demas posiciones sin definir, no existirían. Se van añadiendo por el final, no se ordenan las claves.
Una clave no tiene porque ser numerica, puede ser un string

$a['gato'] = 'cat';


$a[] = 435; Coge la última(mayor) clave y es la que se le aplica a 435.


		OPERADORES DE ARRAY


Podemo sumar arrays (union de dos arrays).
El array de la izquierda, añadiendole los del array de la derecha.
Si hay claves iguales, gana el de la izquierda.

$a = [0=>'a', 1=>'b', 2=>'c'];
$b = [3=>d, 4=>e, 5=>f];

$a + $b ; --> [a,b,c,d,e,f]

$c = [2=>d, 3=>e, 4=>f]

$a + $c ; --> [a,b,c,e,f] --> se pisa la clave 2 y gana la del array $a.


¿Cuándo dos arrays son iguales?

Son iguales si tienen los mismos elementos, las mismas parejas clave-valor.


Y son identicos cuando cuando los valores se evaluan y son iguales.


!= y !== tb se usan.



---------------------------------------------------------------
			FUNCIONES DE ARRAY.
---------------------------------------------------------------

count($a) --> Cuantos elementos tiene un array.
array_sum(...) -->Suma los elementos de un array.
range(0,4) --> Crea un array de los numeros del 0 al 4.
sort($a) --> Ordena por valores el array, devuelve true si lo ha ordenado. elimina las claves.
rsort($a) -->Ordena al reves.
asort($a) --> Ordena por valores pero mantiene las claves, no las pierdes.
arsort($a) --> Ordena por valores al reves y manteniendo las claves.
ksort($a) --> Ordena por claves, y no elimina las claves
krsor($a) --> Ordena al reves por claves.

array_keys($a) --> Devuelve un array solo con las claves.
array_values($a) --> Devuelve un array con los valores.

array_combine(array_keys($a), array_values($a)) --> Combina dos arrays en uno, hay que pasarle como primer parametro un array de claves y luego otro de valores.



array_merge($a) --> sirve para combinar dos arrays. Se modifican las claves de uno de los arrays, y se añaden al final del otro, siguiendo la secuencia numérica de claves de este segundo.

Traversable --> Algo que puedes recorrer.


$a = ['perro' => 'dog', 'gato'  => 'cat'];


foreach ($a as $k => $v){	--> Si solo te interesa los valores $v o $k
	echo "La palabra $k en ingles es $v.\n";
}


---------------------------------
	FUNCIONES
--------------------------------
function suma($a, $b=5){return $a+$b;}

si se usa suma(3,4), sale 7, pero si se le pasa solo un valor, el segundo argumento tomará su valor por defecto que en este caso es 5·

Los valores por defecto debemos indicarlos como ultimos parametros. Por ejemplo $b=5 está detras del $a, no podría ir delante.



ÁMBITOS-->
	'GLOBAL': Las variables que estan definidas a nivel de fichero.Y solo se puede usar a nivel de fichero.

	'LOCAL': Aquella que se define dentro de una función.

	'SUPERGLOBALS': sirven para cualquier ambito, pero ya estan definidas, no se pueden definir nuevas.($_GET,$_POST,_$SESSION,$_COOKIE,..)


Si tenemos una varible global y la queremos usar dentro de una función, deberemos usar:

function(){
global $variable;
...y usarla...
}


Se pueden declarar los tipos de argumentos que pasamos a una función, pero solo pueden ser: int, float, bool, string. Y esto si se le pasa algo que no es del mismo tipo, el interprete se encarga de hacer un conversión implícita.
Al igual que podemos indicar el tipo que retorna una función.

function suma(int $a, int $b):int
{return $a+$b;}


NULLABLE --> hacer un tipo nullable es ponerle ? delante del tipo, ?int --> Permite valores entero y el null.



TIPADO ESTRICTO --> No se define en la misma función, si no que se debe indicar en el archivo donde se llama a la función. La unica excepción es cuando el parametro espera un float y se le pasa un int, SI lo acepta. Es la única excepción.


En el fichero--> Arriba del todo:

declare(strict_types=1);


==========================================0
ORIENTACIÓN A OBJETOS

Las variables guardan referencias a un objeto.
$a = OBJETO;
$b = $a; --> b apunta al mismo objeto que a.
$a = OBJETO1; --> a apunta a un nuevo objeto, pero b sigue apuntando al anterior.

Para acceder a las propiedades y métodos publicos de un objeto usamos ->
$a -> nombre = "Jose";
$b -> saluda();
machacamos la propiedad nombre del objeto.

$a = OBJETO;
$b = &$a; //A b se le asigna por referencia a. b apunta al mimso objeto que a.
$a = OBJETO1; //b tb apunta al nuevo objeto.

$a = OBJETO;
$b = clone $a; -->b apunta a una copia de OBJETO(copia superficial, no profunda) si el OBJETO tuviese objetos como propiedades
				estos no se clonarian, si no que las propiedades objetos de la copia apuntarian a las propiedades objetos del OBJETO

Un objeto es == a otro cuando instancian a la misma clase y cuando sus propiedades tienen los mismos VALORES
Un objeto es === a otro cuando son el mismo objeto.

Podemos usar las constantes de las clases, con el nombre de la clase seguido de la resolución de ámbito (::)
DateTime::ATOM; Llamamos a la constante ATOM de DateTime.


------------------ CLASE DATETIME ----------------
$a = new DateTime;
$a->setTimezone(new DateTimeZone('Europe/Madrid')); --> esto te cambia de UTC, al horario de madrid

-------------------- EXCEPCIONES ----------------------
Instancia de la clase Exception o de la clase Error.
-ErrorException, solo existe para convertir los errores no manejados en excp (Subclase de Exception)
-Exception, para lanzar excepciones propias
-Error, base de todos los errores de php //Convierte en excep los errores.

el archivo erro_reporting se encuentra en /etc/php/7.1/cli/php.ini

Para cazar cualquier exc o error
try{
	...
} catch(Exception|Error $e){
	echo $e->getMessage();
	die();
}

----------------- POSTGRES -----------------------
Para instalar postgresql:
desde .conf/scripts
ejecutamos ./postgresql-install.sh

para ver todas las bases de datos:
sudo -u postgresql psql -l


----------- COMENZAMOS NUESTRO FILMAFFINITY -------
Vamos a crear una base de datos que contengan las peliculas:

peliculas(_id,titulo,anyo,sinopsis,duracion,genero_id(claveAjena))
generos(id,genero)

Para entrar en la base de datos template1 -> sudo -u postgres psql -d template1
Vamos a modificar template1:
create extension pgcrypto; -->creamos esta extensión

HACER SIEMPRE, PARA QUE FUNCIONE

creamos una base de datos(nombre fa): sudo -u postgres createdb fa (fa->filmaffinity)
creamos un usuario (nombre fa): sudo -u postgres createuser -P fa (-P para que te pida la contraseña y generarla)

psql -U fa -h localhost -d fa -> para entrar en la base de datos fa (-d) con el usuario fa (-U) en mi maquina (-h localhost)

psql -U fa -h localhost -d fa < fa.sql : inyecta el archivo fa.sql y lo ejecuta dentro de la base de datos fa con usuario fa.

Desde psysh -> vamos a conectarnos a la base de datos ya creada.
Debemos instanciar a la clase PDO.
$pdo (o $con ) = new PDO('pgsql:host=localhost;dbname=fa'(tipo de base de datos, host nuestro y base de datos a la que nos conectamos),'fa'(usuario),'fa'(contraseña))

Ya tenemos la instancia, podemos trabajar con ella, vamos a hacer un SELECT
$sentencia = $pdo->query('SELECT * from generos;') //devuelve una sentencia, que la guardamos
$res = $sentencia->fetchAll(); //guardo en res, el array que saca el fetchAll() de la sentencia
$res[0][0] = 1; //consulto en el array res, el primero, que a su vez es un array, llamo a la posicion 0
$res[0]['id'] = 1 //id es la primera posicion, de la primera posicion de $res;
 //Se puede llamar por el indice (numero) o por el nombre de la columna ('id');
 query(...) --> te ejecuta una sentencia (select) y te devuelve el resultado de la sentencia;
 fetchAll() --> Te devuelve todas las filas.
 fetch() --> te devuelve la siguiente fila, tiene un contador interno, que sabe que fila te ha dado.
 			si te da false, es que ya no hay mas filas que mostrar.
fetchColumn() --> devuelve columna a columna, de una fila, y va pasando de fila
				por lo que solo se puede coger una columna de cada fila.
rowCount()--> el numero de filas.

$pdo->exec(operaciones que no provoquen resultados, insert,update)-> devuelve el nº de filas afectadas.
$pdo->prepare(); //Aqui dentro usamos marcadores ':'
$pdo->execute([:marcador => valor]);

dentro de la base de datos:
\d -> te dice las bases de datos que hay


	TIPOS SQL --------- TIPOS PHP
	nº Entero ----------- entero
	null ---------------- null
	bool ---------------- bool
	el resto ------------ cadenas




//INTRODUCIR TEMARIO DE TRANSACCIONES **TAREA**
Las transacciones ofrecen Atomicidad, Consistencia, aislamiento y durabilidad. En resumen, hace que un trabajo llevado
a cabo sobre una base de datos, sea aplicado de forma segura y sin interferencias de otras conexiones.
Una transaccion se implementa para hacer que el lote de cambios se aplique a la vez.
Para empezar una transaccion:
PDO::beginTransaction();
para finalizarla:
PDO::commit();
PDO::rollback();


--------------- FILTRADO ------------------
Validación --> solo podemos decir si es valido o no el valor.
Saneado --> podemos también modificar el dato durante el saneado.

Lo que debemos tener en cuenta es:
- Filtrar la entrada: Validación y saneado básico(trim)

- Escapar la salida:

Resolvería tres problemas:
	- La b.d. acepte los datos al insertar/modificar.
	- Trabajar con datos correctos.
	- Resuelve el Cross-Site Scripting (Escapando la salida).


-------------- SESIONES ----------------------------
PHPSESSID --> Identificador de sesion.
$_SESSION --> Array que contiene las variables de sesion.
El servidor en cuestión almacena una sesion para cada usuario que la visita, y le dice al usuario que guarde
un PHPSESSID, para saber a qué usuario pertenece la sesión que guarda. Para que en un futuro cuando el mismo
usuario quiera entrar, se quede guardado la lista de favoritos, el carrito,...

Para crear una sesion o continuar(si ya estaba creada) --> session_start();


------------- ESPACIOS DE NOMBRES -------------
namespaces;

Nombre totalmente cualificado --> namespace\NombreClase;

Para diferenciar otras clases con mismo nombre, pero en otro espacio diferente.

Las 5 'cosas' que se ven afectadas por los espacios de nombres son:
	-Clase
	-Interfaz
	-Rasgo
	-Constante
	-Funcion

----------- 8) INTEROPERABILIDAD-------------------------

	- Versionado semántico
	- Composer
	- Autoloading de clases / interfaces / traits
	- Recomendaciones del PHP-FIG (Estándares)


	- VERSIONADO SEMÁNTICO:

		A la hora de enumerar nuestras versiones, no se hace de cualquier manera, si no hay que seguir una serie de
 	recomendaciones, normas o estándares.
 	Podemos ir haciendo versiones de nuestros programas en GitHub con el etiquetado (tag), poniendo v1.0.0, o
	con los releases que ofrecen mas información que los tags.

	El versionado semantico es la manera en como hay que indicar las versiones, para que todo programador sepa
	interpretar un numero de versión.

	SIEMPRE serán tres numeros -> X,Y,Z (numero mayor, numero menor y parche)
		- Cuando se corrige un fallo y el programa sigue funcionando igual, se incrementa el parche (Z)
		- Todo cambio que haga que el programa funcione diferente, pero no lo haga incompatible con la version anterior,
		 hace aumentar el numero menor (Y). Cuando se aumenta el menor, el parche pasa a valer 0.
		- Los cambios que si rompen la compatibilidad, hace incremetar el numero mayor (X). Mi programa deja de funcionar
		 con esa libreria de la que depende y ha hecho esta nueva versión.

		 API -> Es el punto de conexión entre mi código y la librería que estoy usando.

		 como saber que versiones van antes o despues:
		 v1.0.0-alpha < v1.0.0-alpha.1 < v1.0.0-beta < v1.0.0-beta2 < v1.0.0-rc1 < v1.0.0
		 rc -> release candidate (está apuntito de salir la versión)


	- COMPOSER (Sistema de gestión de dependencias):

		Debemos instalar composer.
		Desde .conf/
		Actualizamos .conf/, dentro de scripts, instalar composer-install.sh y luego composer-postinstall.sh.

	-----PARA INCLUIR UNA LIBRERIA ---- composer require 'dependencia';
		Esto incluye la version de producción, si queremos la versión en desarrollo, debemos indicar --dev al final.

		Aunque composer install, instala las dependencias en desarrollo por defecto, si queremos las de produccion
		debemos poner --no-dev.

		O tambien podremos incluir la dependencia en el archivo composer.json y luego ejecutar composer install.
		O con composer update, actualiza los paquetes compatibles con las versiones y modifica lock para que quede
		 constancia.


		El composer trabaja a nivel de proyecto en local.
		Al ejecutar el composer con alguna libreria, se te crea la carpeta vendor que es donde incluye todo el codigo
		de las dependencias de mi libreria, el composer.lock y composer.json.

	CARPETA VENDOR:
		La carpeta vendor, no se puede pushear a git ya que es composer es el que se la trae.
		 Por lo que la debemos incluir en el .gitignore.
		Si eliminamos la carpeta vendor, con un composer install, la vuelve a traer

	COMPOSER.JSON:
		Incluye la dependencia que indiquemos, esto lo indicamos con el composer require 'dependencia'
		Archivo esencial!! Ya que indica la dependencia que necesita nuestro programa para funcionar.
		Nos indica tb la versión que debe tener la dependencia para que nuestro programa funcione. (Restricción de versiones)

	COMPOSER.LOCK:
		Se genera automaticamente.
		El composer.lock es la que dice que versión de nuestra dependencia se está instalando, y la bloquea.
		Así podras usar las mismas versiones de los paquetes. Aunque salgan versiones nuevas, no se actualizará,
		hasta que tu lo permitas. Así evitaremos problemas de compatibilidad.

	a) El composer.lock en un principio no existe, al ejecutar el composer install, mira en el composer.json, las dependencias
	que necesita y las versiones de estas que necesita y se las trae, es aquí cuando se crea el composer.lock y se indica
	la versión que se ha instalado.

	b) Si ya existe el composer.lock, y se ejecuta el composer install, compara los dos archivos y mira en el json las dependencias
	si todos los paquetes especificados aparecen tb en el lock, y se instalarán los que no estan en el lock estando en el json (pq los
	hemos incluido mas tarde)

	------------Restricciones sobre las versiones:--------
	*En composer.json:

	"symfony/console": "4.3.1" 	-> esto indica que quieres esa versión, y solo esa de la dependencia.
	"symfony/console": "4.3" 	-> esto indica que quiere la versión 4.3.0.
	"symfony/console": "4" 		-> esto indica que quiere la versión 4.0.0.
	"symfony/console": ">=4.2.1 < 4.3.0"-> esto indica que quiere la versión 4.2.X cualquier parche
	"symfony/console": ">=4.2.1 < 4.3.0 || 4.5.2"-> esto indica que quiere la versión 4.2.X cualquier parche ó 4.5.2
	"symfony/console": "1.0 - 2.0 "-> esto indica que quiere la versión >= 1.0.0 < 2.1 en ese rango, con - te permite coger 2.0.2
	"symfony/console": "1.0.0 - 2.1.0 "-> esto indica que quiere la versión >= 1.0.0 <= 2.1.0 en ese rango
	"symfony/console": "1.4.* "		-> esto indica que quiere la versión 1.4.X cualquier parche
	"symfony/console": "~4.3.1 "	-> version minima con la que tu programa funciona bien, permitimos el aumento del parche(1), de los demas no
	"symfony/console": "~4.3 "		-> version minima con la que tu programa funciona bien, permitimos el aumento del menor(3), de los demas no
	"symfony/console": "~4 "	-> version minima con la que tu programa funciona bien, NO permitimos el aumento del ultimo numero

	LA VIRGUILILLA y GORRITO, NO PERMITE CAMBIOS EN MAYOR, PORQUE GENERARIAN PROBLEMAS DE COMPATIBILIDAD

	"symfony/console": "^4.3.1 "	-> version minima con la que tu programa funciona bien, permitimos el aumento de parche(1) y menor (3)
	"symfony/console": "^4.3 "		-> version minima con la que tu programa funciona bien, permitimos el aumento del menor(3) el parche tb

	La 'estabilidad mínima' quiere decir que el composer por defecto se descarga los ultimos paquetes estables. Y no los
	que estan en desarrollo.
	Esto lo podriamos modificar en el composer.json, poniendo arriba:

	"minimun-stability": "dev",

	Le podemos meter -> stable, dev, alpha, beta, RC.

	La restricción "@dev" hace que en ese paquete particular, te descargues la ultima versión de desarrollo.

	semver.mwl.be --> pagina donde podemos practicar el tema de las restricciones de versiones


--------------------------AUTOLOADING -------------------------------

	Permite incluir las clases cuando sea requerida.
	Composer tiene un require especial -> require '/vendor/autoload.php';
	Y esto hace que cada vez que sea requerida una clase, se implementa sola.
	El autoloading carga, clases, interfaces y rasgos.











---------------------- YII ------------------------
Transparencias --> dwese.iesdonana.org/slides/introduccion-a-yii2.html#

Framework--> proporciona funcionalidades genércias que el programador puede cambiar
selectivamente, escribiendo código específico para una app específica.
Se puede considerar como una app genérica incompleta en la cual el usuario
puede hacer uso de ella para crear una app en particular.
Ejemplos de framework web para php:
	- Symfony
	- Laravel
	- CakePHP
	- CodeIgniter
	- Yii

Microframework--> se refiere a un framework web minimalista, carece de muchas
funcionalidades que posee un framework web completo (full-stack)

Libreria vs Framework --> Los framework tiene 3 caract, que las diferencia de las
librerias:
	- Inversión del control: el flujo de control del programa viene dictado por
	el framework y no por el programa.
	- Extensibilidad: puede sobreescribir código para realizar funcionalidades
	específicas.
	-No modificable: El codigo del framework no se puede modificar, se puede ampliar,
	por eso es extesible, pero no modificar su codigo.

La principal diferencia:
	- Con librerias: El código llama a la libreria por lo que el control lo
	tiene el código.
	- Con framework: El framework llama al código po lo que el control lo
	tiene el framework.


Página de yii --> www.yiiframework.com : lo visitaremos bastante por aquello de la guia
	y de la API.

El framework de yii no es mas que un paquete de composer.

---------------- AYUDA --------------------------
el comando -> hub create 'nombre'
crea un repositorio remoto y lo enlace con el repositorio local en el que estas.
Deberia pushear la rama al remoto -> git push -u origin master
-------------------------------------------------

La primera vez que entramos en un proyecto de yii
Debemos indicar al atom que es un proyecto, para ello:
Ctrl+Mayus+P -> buscamos save project, y pulsamos save.
Ctrl+Mayus+P -> PHP ide serenata, tb lo ejecutamos.

Para ejecutar un proyecto yii-> .yii/ serve


-------------- MODELO VISTA-CONTROLADOR--------------
 Separar en 3 'capas' :
 	-controlador --> se encarga de gestionar la Web request
 	-modelo --> Gestiona los datos dentro de la aplicacion. Tb se encarga de las
	validaciones, metodos,... de los datos(CRUD).(Ej: Peliculas,Usuarios,...)
	-vista --> Es la que se encarga de la interfaz, es decir, lo que se ve por pantalla...
	Los formularios para recuperar datos, mostrar una lista de peliculas por ejemplo..

---------------------------------------------------------------
Mapeador Objeto-Relacional (ORM):
	Se encarga de hacer la correspondencia entre la base de datos (tablas) y
	las clases y/o objetos de los modelos.
	Convierte las tablas en clases, las filas en objetos y las columnas en atributos.
	En yii2 tenemos ActiveRecords como ORM.
-------------------------------------------------------------
Para acceder al generador automático -> index.php?r=gii

Cambiamos los datos de la base de datos para que no nos de error:
en la carpeta config, el archivo db.php, debemos cambiar el $dbname, $username y $password

------- PARA COMENZAR UN PROYECTO YII2 ---------
Para crear un proyecto nuevo con la estructura de la plantilla básica:
 $ composer create-project yiisoft/yii2-app-basic directorio

Creará un directorio llamado directorio donde se volcará el contenido de la plantilla y quedará
el proyecto listo para empezar su desarrollo.


----------------- MODELOS ------------------
Partes de la arquitectura MVC.
Son objetos que representan datos, reglas y lógica de negocio.
Se crean heredando de yii\base\Model
Esto proporciona muchas características útiles:
	-Atributos -> solo los modelos poseen atributos.
	-Etiquetas de atributos
	-Asignación masiva
	-Reglas de validación
	-Exportación de datos

----------------------- DIFERENCIA (Variable instancia, Propiedad) ------------------------
+ Variable de instancia
	Se declara en el ćodigo fuente de la clase:

class Pepe
{
	public $hola;
}

$pepe = new Pepe();
echo $pepe->hola;

+ Propiedades:
	Son características que tienen todos los componentes de una aplicación Yii2
	En principio, todas las variables de instancia públicas de una clase se pueden considerar
	propiedades de la clase.
	Además, se pueden declarar otras propiedades mediante getters y setters:

class Pepe extends \yii\base\Component
{
	public $hola;
	private $_adios;
	public function getAdios()
	{
		return $this->_adios;
	}

	public fuction setAdios($adios)
	{
		this->_adios = $adios;
	}
}
---------------- ATRIBUTOS ------------
	Los modelos representan los datos de negocio en forma de atributos.
	Cada attb es como una propiedad públicamente accesible de un modelo.
	atributes()->Define los atributos del modelo dependiendo de las variables de instancia.
	Que incluirá todos los atributos del modelo.

----------------- DEFINICIÓN DE ATRIBUTOS ---------------
De entrada, si la clase modelo hereda directamente de yii\base\Model esta contendrá
todas sus variables no estáticas como atributos.

Se puede sobreescribir el método attributes() de yii\base\Model.

	public function attributes()
	{
		return['var1','var2']; -> Aqui incluyo las variables de instancia de la clase
								que quiero que sean atributos en el modelo.

	}

-------------- ESCENARIOS ----------------
Un modelo se puede usar en diferentes escenarios.
Ej: Un modelo de User, para recoger los datos en login y tb para registrar un nuevo User.

En escenarios diferentes, un modelo puede tener reglas y lógica de negocio diferente.

Ej: el attb correo, puede ser obligatorio para registrar pero no para logear.

Cada escenario define qué attb se pueden asignar masivamente y qué reglas de validación se aplican:
	-La asignación masiva permite asignar valores a varios attb al mismo tiempo en una sola operacion.
	-Las reglas de validación determinan si los atributos de un modelo son válidos, osea, si cumplen
	determinadas condiciones.

	Ej:
	class User extends \yii\db\ActiveRecord
	{
		const SCENARIO_LOGIN = 'login';
		const SCENARIO_REGISTRO = 'registro';

		//sobreescribimos el metodo. Devolveria ['default' => ['nombre', 'correo', 'password'],];
		public function scenarios()
		{
			return [
				self::SCENARIO_DEFAULT => ['todos',...],
				self::SCENARIO_LOGIN => ['nombre','password'],
				selft::SCENARIO_REGISTRO => ['nombre','correo','password'],
			];
		}
	}

Los atributos activos deben aparecer en el escenario actual y en rules().

//metodo yii\base\Model::rules() ademas de para validacion, y saneado interesante para los escenarios.
//Es 'necesario' sobreescribirlo. Los atributos que estan en las reglas de validacion ya se consideran seguros.

class User extens \yii\db\ActiveRecord
{
	...

	public function rules()
	{
		return [
			//nombre, correo, asunto y cuerpo son obligatorios.
			[['nombre','correo','asunto','cuerpo'], 'required'],

			//el crreo debe ser una direccion de e-mail válida:
			['correo','email'],
		];
	}
}

----------- REGLAS ACTIVAS -----------
	- Las reglas activas son aquellas reglas que se aplican al escenario activo.
	- Se aplica a todos los escenarios.
	- Podemos indicar que una regla sólo se aplique a un determinado escenario usando la opción on.

	public function rules()
	{
		return [
			[['edad'], 'numeric', 'on' => self::SCENARIO_A],
		];
	}

Podemos definir todo el rules:

class User extens \yii\db\ActiveRecord
{
	...
	public function rules()
	{
		return[
			[['nombre','correo','asunto','cuerpo'],'required','on' => [self::SCENARIO_DEFAULT, selft::SCENARIO_A,],
			['edad'], 'numeric', 'on' => [self::SCENARIO_A,]],
		];
	}
}
